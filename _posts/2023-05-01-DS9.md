---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"

title: "[자료구조] 탐색트리 -1"

categories:
  - ds
tags:
  - DS
  - 자료구조
---

**본문과 관련하여 실습한 전체코드는 리파지토리에 별도 작성하였습니다.**<br>
: https://github.com/ejImDev/data_structure_study.git<br><br>



## 탐색트리
- 저장된 데이터에 대해 탐색, 삽입, 삭제, 갱신 등의 연산을 수행할 수 있는 자료구조<br>
- 배열이나 연결리스트는 각 연산을 수행하는데 O(N) 시간이 소요<br>
- 스택이나 큐는 특정 작업에 적합한 자료구조<br>
- 이진탐색트리, AVL트리, 2-3트리, 레드블랙트리, B트리 등<br><br>

## 이진탐색트리 (BST)
- 이진탐색의 개념을 트리 형태의 구조에 접목한 자료구조<br>
- 이진탐색 : **정렬된 데이터**의 중간에 위치한 항목을 기준으로 데이터를 두 부분으로 나누어 가며 특정 항목을 찾는 탐색 방법 (데이터는 오름차순으로 정렬 되어있어야 함)<br>
- 이진탐색트리의 특징 중 하나는 트리를 중위순회하면 정렬되어 출력 됨<br>
- 이진탐색트리는 이진트리로서 각 노드가 다음과 같은 조건을 만족함<br>
	- 각 노드 n의 키값이 n의 왼쪽 서브트리에 있는 노드들의 키값보다 크고, 오른쪽 서브트리에 있는 노드들의 키값보다 작다. <br><br>

## 이진탐색트리 구현
- 노드 클래스는 이진트리의 구현에 사용된 노드와 거의 유사<br>
- 노드 객체는 id(키), name(키에 관련된 정보), 왼쪽 자식과 오른쪽 자식을 각각 가리키기 위한 left, right<br><br>

1. 노드 클래스
``` java
public class Node <Key extends Comparable<Key>, Value> {
	private Key id;
	private Value name;
	private Node left, right;
	public Node(Key newId, Value newName){
		id = newId;
		name = newName;
		left = right = null;
	}
	public Key getKey() { return id; }
	public Value getValue() { return name; }
	public Node getLeft() { return left; }
	public Node getRight() { return right; }
	public void setKey(Key newId) { id = newId; }
	public void setValue(Value newName) {name = newName; }
	public void setLeft(Node newLeft) {left = newLeft; }
	public void setRight(Node newRight) {right = newRight; }
}
```

2. BST 클래스
``` java
public class BST<Key extends Comparable<Key>, Value>{
	public Node root;
	public Node getRoot() { return root; }
	public BST(Key newId, Value newName){
		root = new Node(newId, newName);
	}
	...
}
```

3. 연산 메소드<br>
- get 메소드<br>
탐색하고자 하는 Key가 k라면, 루트노드의 id와 k를 비교하는것으로 탐색을 시작<br>
``` java
public Value get(Key k) { return get(root, k); }
public Value get(Node n, Key k) {
	if(n==null) { return null; }
	int t = n.getKey().compareTo(k);
	if(t>0){
		return get(n.getLeft(), k);
	} else if (t<0) {
		return get(n.getRight(), k);
	} else {
		return (Value)n.getValue();
	}
}
```

- 삽입 연산 (이파리 노드에 삽입)<br>
	- 삽입은 탐색 연산과 거의 동일<br>
	- 탐색 연산의 마지막에서 null이 반환되어야 할 상황에서 null 대신 삽입하고자 하는 값을 갖는 새 노드를 생성하고, 부모노드와 연결하면 삽입 연산이 완료<br>
	- 단, 이미 트리에 존재하는 id를 삽입할 경우 name을 갱신<br>
``` java
public Value put(Key k, Value v) { root =  put(root, k, v); }
public Node put(Node n, Key k, Value v) {
	if(n==null) { return new Node(k, v); }
	int t = n.getKey().compareTo(k);
	if(t>0){
		n.setLeft(put(n.getLeft(), k, v));
	} else if (t<0) {
		n.setRight(put(n.getRight(), k, v));
	} else {
		n.setValue(v);
	}
	return n;
}
```


- 최솟값 찾기<br>
	- 루트 노드로부터 왼쪽 자식노드를 따라 내려가며, null을 만났을 때 null의 부모노드가 가진 id<br>
``` java
public Key min() {
	if(root==null) {
		return null;
	}
	return (Key) min(root).getKey();
}
private Node min(Node n) {
	if(n.getLeft()==null) {
		return n;
	}
	return min(n.getLeft());
}
```

- 최솟값 삭제연산
	- 최솟값을 가진 노드를 찾아낸 뒤, x의 부모노드 p와 x의 오른쪽 자식노드 c를 연결<br>
	- 이 때 c가 null이더라도 자식으로 연결<br>
	- deleteMin() 메소드는 임의의 id를 가진 노드를 삭제하는 delete() 메소드에서 사용<br>
``` java
public deleteMin() {
	if(root==null) {
		System.out.print("empty 트리");
		root = deleteMin(root);
	}
}
public Node deleteMin(Node n) {
	if(n.getLeft()==null){
		return n.getRight();
	}
	n.setLeft(deleteMin(n.getLeft()));
	return n;	
}
``` 

> 참고 자료 : '경기대학교 소프트웨어중심대학사업단 - JAVA 자료구조' https://youtu.be/G-vfkaLP2vo
