---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"
  
title: "[JAVA] 알고리즘 문제풀이 기초 - HashMap, TreeSet -2"

categories:
  - javaTest
tags:
  - JAVA
  - Test
---

## HashMap, TreeSet

### 모든 아나그램 찾기 (4-4)

- 설명 : S문자열에서 T문자열과 아나그램이 되는 S의 부분문자열의 개수를 구하는 프로그램을 작성하세요. 아나그램 판별시 대소문자가 구분됩니다. 부분문자열은 연속된 문자열이어야 합니다.  <br><br>

- 입력 : 첫 줄에 첫 번째 S문자열이 입력되고, 두 번째 줄에 T문자열이 입력됩니다. S문자열의 길이는 10,000을 넘지 않으며, T문자열은 S문자열보다 길이가 작거나 같습니다.<br><br>

- 출력 : S단어에 T문자열과 아나그램이 되는 부분문자열의 개수를 출력합니다.<br><br>

- 작성답안

``` java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Main t = new Main();
        Scanner scan = new Scanner(System.in);
        String str1 = scan.next();
        String str2 = scan.next();

        System.out.println(t.solution(str1, str2));
    }

    public Integer solution(String str1, String str2){
        int result = 0;

        HashMap<Character, Integer> map = new HashMap<>();
        for(char c: str2.toCharArray()){
            map.put(c, map.getOrDefault(c, 0)+1);
        }
        int size = str2.length();
        char[] ch = str1.toCharArray();
        for(int i=0; i<size-1; i++){
            if(map.containsKey(ch[i])) {
                map.put(ch[i], map.get(ch[i])-1);
            }
        }
        int lt=0;
        for(int rt=size-1; rt<str1.length(); rt++){
            int sum = 0;
            if(map.containsKey(ch[rt])) {
                map.put(ch[rt], map.get(ch[rt])-1);
            }
            boolean chk = true;
            for (Character key : map.keySet()) {
                if (map.get(key)!=0) chk=false;
            }
            if(chk) result++;

            if(map.containsKey(ch[lt])) map.put(ch[lt], map.get(ch[lt])+1);
            lt++;
        }

        return result;
    }
}
```

- 풀이 답변
``` java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Main t = new Main();
        Scanner scan = new Scanner(System.in);
        String str1 = scan.next();
        String str2 = scan.next();

        System.out.println(t.solution(str1, str2));
    }

    public Integer solution(String str1, String str2){
        int result = 0;

        HashMap<Character, Integer> amap = new HashMap<>();
        HashMap<Character, Integer> bmap = new HashMap<>();
        for(char c: str2.toCharArray()){
            bmap.put(c, bmap.getOrDefault(c, 0)+1);
        }

        int size = str2.length();
        char[] ch = str1.toCharArray();
        for(int rt=0; rt<size-1; rt++){
            amap.put(ch[rt], amap.getOrDefault(ch[rt], 0)+1);
        }
        int lt=0;
        for(int rt=size-1; rt<str1.length(); rt++){
            amap.put(ch[rt], amap.getOrDefault(ch[rt], 0)+1);

            if(amap.equals(bmap)) result++;

            amap.put(ch[lt], amap.get(ch[lt])-1);
            if(amap.get(ch[lt])==0) amap.remove(ch[lt]);
            lt++;
        }

        return result;
    }
}
```

- 특징
	1. 내 풀이의 경우 map을 하나만 만들어서 거기서 차감을 하고, 모든값이 0일때만 카운트되도록 했는데<br>
	2. 알고보니 두개의 map도 equals로 비교가 가능했다!!!!<br>
	3. 두개의 map을 만들어, 긴 문자열을 투포인트 방식으로 가감하고
	4. amap.equals(bmap) 으로 비교해주면 됨<br>
