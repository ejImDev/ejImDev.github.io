---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"

title: "[자료구조] Hash Table -1"

categories:
  - ds
tags:
  - DS
  - 자료구조
---

**본문과 관련하여 실습한 전체코드는 리파지토리에 별도 작성하였습니다.**<br>
: https://github.com/ejImDev/data_structure_study.git<br><br>

## 해시테이블
- 이진탐색트리의 성능을 개선한 ACL 트리의 삽입과 삭제 연산의 수행시간은 각각 O(logN) <br>
- 그보다 더 효율적인 연산을 위해, 키와 1차원 배열의 인덱스의 관계를 이용하여 키(항목)를 저장한다 <br><br>

- 키를 배열의 인덱스로 사용하면 메모리 낭비가 심해질 수 있음 <br>
- 문제해결을 위해 키를 변환하여 배열의 인덱스로 사용<br>
- **키를 간단한 함수를 사용해 변환한 값을 배열의 인덱스로 이용하여 항목을 저장하는 것을 해싱**이라고 함<br>
- 해싱에 사용되는 함수를 해시함수(Hash Function)라고 함<br>
- 해시 함수가 계산한 값을 해시 값(Hash value) 또는 해시 주소라고 함<br>
- 항목이 해시값에 따라 저장되는 배열을 해시 테이블(Hash Table)이라고 함<br><br>

- 아무리 우수한 해시함수를 사용하더라도 2개 이상의 항목을 해시테이블의 동일한 원소에 저장하여야 하는 경우가 발생<br>
- 서로 다른 키들이 동일한 해시값을 가질 때 충돌(Collision) 발생<br><br>

## 해시함수
- 가장 이상적인 해시함수는 키들을 균등하게 해시테이블의 인덱스로 변환하는 함수<br>
- 일반적으로 키들은 부여된 의미나 특성을 가지므로 키의 가장 앞 부분 또는 뒤의 몇 자리 등을 취하여 해시값으로 사용하는 방식의 해시함수는 많은 충돌을 야기시킴<br>
- 균등하게 변환한다는 것은 키들을 해시테이블에 랜덤하게 흩어지도록 저장하는 것을 뜻함<br>
- 해시함수는 키들을 균등하게 해시테이블의 인덱스로 변환하기 위해 의미가 부여되어 있는 키를 간단한 계산을 통해 '뒤죽박죽' 만든 후 해시 테이블의 크기에 맞도록 해시값을 계산<br>
- 하지만 아무리 균등한 결과가 보장하는 해시함수이더라도 함수 계산 자체에 긴 시간이 소요된다면 해싱의 장점인 연산의 신속성을 상실하므로 그 가치를 잃음<br><br>

### 대표적인 해시함수
1. 중간제곱(Mid-square) : 키를 제곱한 후, 적절한 크기의 중간부분을 해시값으로 사용<br><br>

2. 접기(Folding) 함수 : 큰 자릿수를 갖는 십진수를 키로 사용하는 경우. 몇 자리씩 끊어서 만든 숫자들의 합을 이용해 해시값을 만든다<br>
	- 예를들어, 123456789012에대해서 1234+5678+9012 = 15924를 계산한 후에 해시테이블의 크기가 3이라면 15924에서 3자리 수만을 해시값으로 사용<br><br>

3. 곱셉(Multiplicative 함수) : 1보다 작은 실수 w를 키에 곱하여 얻은 숫자의 소수 부분을 테이블 크기 M과 곱한다. 이렇게 나온 값의 정수부분을 해시값으로 사용<br>
	- 예를들면, 테이블크기 M = 127이고 키가 123456789인경우, 123456789 * 0.61803 = 76299999.30567, 0.30567*127 = 38.82009 이므로 38을 해시값으로 이용<br>
	- h(key) = (int)(key*w)%1 * M이다<br><br>

4. 해시함수들의 공통점<br>
	- 키의 모든 자리 숫자들이 함수 계산에 참여함으로써, 계산 결과에서는 원래의 키에 부여된 의미나 특성을 찾아볼 수 없게 된다는 점<br>
	- 계산 결과에서 해시테이블의 크기에 따라 특정부분만을 해시값으로 활용한다는 점<br><br>

5. 나눗셈(Division) 함수<br>
	- 가장 널리 사용됨<br>
	- 키를 소수 M으로 나눈 뒤, 그 나머지를 해시값으로 사용<br>
	- h(key) = key % M이고, 따라서 해시테이블의 인덱스는 0에서 M-1이 됨<br>
	- 여기서 제수로 소수를 사용하는 이유는 나눗셈 연산을 했을 때, 소수가 키들을 균등하게 인덱스로 변환시키는 성질을 갖기 때문<br><br>

## 자바의 hashCode()
- 자바의 모든 클래스는 32비트 int를 리턴하는 hashCode()를 포함하고 있고, hashCode()는 객체를 int로 변환하는 메소드<br>
- 자바의 hashCode()는 이론적으로 어떤 종류의 객체(사용자가 정의한 객체를 포함)라도 해싱을 할 수 있도록 지원<br>
- hashCode()는 key1.equals(key2)가 true면, key1.hashCode() == key2.hashCode()가 성립한다는 조건 하에 구현되어 있음<br>
- 2개의 키가 동일하면 각각의 hashCode 값도 같아야 함<br><br>


## 개방주소방식
- 해시테이블 전체를 열린 공간으로 가정하고 충돌된 키를 일정한 방식에 따라서 찾아낸 empty 원소에 저장

- 대표적인 개방주소 방식
	- 선형조사
	- 이차조사
	- 랜점조사
	- 이중해싱
	- 폐쇄주소 방식의 충돌 해결 방법은 키에 대한 해시값에 대응되는 곳에만 키를 저장

### 선형조사
- 충돌이 일어난 원소에서부터 순차적으로 검색하여 처음 발견한 empty 원소에 충돌이 일어난 키를 저장<br>
- h(key) = i라면, 해시테이블 a[i], a[i+1], a[i+2], ... a[i+j] 를 차례로 검색하여 첫번째로 찾아낸 empty 원소에 key를 저장<br>
- 해시테이블은 1차원 배열이므로, i+j가 M이 되면 a[0]을 검<br>
- (h(key)+j) % M 의 식으로 표현 가능, j = 0,1,2,3 ...<br><br>

- 선형조사는 순차탐색으로 empty 원소를 찾아 충돌된 키를 저장하므로 해시테이블의 키들이 빈틈없이 뭉쳐지는 현상이 발생 [1차 군집화]<br>
- 이러한 군집화는 탐색, 삽입, 삭제 연산 시 군집된 키들을 순차적으로 방문해야 하는 문제점을 야기<br>
- 군집화는 해시테이블에 empty 원소 수가 적을수록 더 심화되며 해시성능을 극단적으로 저하시킴<br><br>

> 참고 자료 : '경기대학교 소프트웨어중심대학사업단 - JAVA 자료구조' https://youtu.be/C6wua2t6MV0
