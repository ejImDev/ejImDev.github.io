---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"

title: "[알고리즘] 정렬 -2"

categories:
  - algorithm

tags:
  - 알고리즘
---

## 정렬

### 퀵 정렬

- 특정 데이터를 기준으로 주어진 배열을 2개의 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
- 피벗이 제자리를 잡도록 하여 정렬하는 방식

- 피벗
	- 주어진 배열을 두 부분배열로 분할하는 기준이 되는 특정 데이터
	- 보통 주어진 배열의 첫 번째 데이터로 지정
	
[![quick-sort.png](https://i.postimg.cc/htt37XgF/quick-sort.png)](https://postimg.cc/zV4ksXVp)

[![quick-sort2.png](https://i.postimg.cc/Ss6qZgsY/quick-sort2.png)](https://postimg.cc/2bSPyFnC)

``` c
QuickSort(A[], n){
	if(n > 1) {
		//1. 피벗을 기준으로 두 부분 배열로 분할
		// 피벗은 제자리를 잡은 피벗의 인덱스를 표시
		pivot = Partition(A[0..n-1], n);
		
		//2. 왼쪽 부분 배열에 대한 퀵 정렬의 순환 호출
		QuickSort(A[0..pivot-1], pivot);
		
		//3. 오른쪽 부분 배열에 대한 퀵 정렬의 순환 호출
		QuickSort(A[pivot+1..n-1], n-pivot=1);
	}
}

int Partition(A[], n) {
	Left = 1; Right = n-1;
	while(Left<Right) {
		while(Left<n && A[Left]<A[0]) Left++;
		while(Right>0 && A[Right]>=A[0]) Right--;
		if(Left<Right) A[Left]와 A[Right]의 위치 교환
		else 피벗 A[0]와 A[Right]의 위치 교환
	}
	return (Right);
}
```

- 분할 함수 Partition()의 특징
	- 각 데이터는 피벗과 1회 또는 많아야 2회씩 비교
	- 성능 : O(n)

- 퀵 정렬 QuickSort()의 특징
	- 수행시간은 분할되는 두 부분 배열의 크기에 따라 달라짐
	- 최악의 경우 = 0:n-1 or n-1:0, 피벗이 항상 부분배열의 최솟값 또는 최댓값이 되는 경우 = 입력데이터가 정렬되어있고 피벗을 첫번째 원소로 정한 경우 : O(n^2^)
	- 최선의 경우 = n/2:n/2, 피벗을 중심으로 항상 동일한 크기의 두 부분 배열로 분할되는 경우 =  O(nlogn)
	- 평균 : O(nlogn)
	- 따라서 피벗 선택의 임의성만 보장되면 평균 수행시간을 보장 => 배열에서 임의의 값을 선택한 후 첫 번째 원소와 교환

<table>
<tr>
<td>평균 성능</td>
<td>최선 성능</td>
<td>최악 성능</td>
<td>제자리 정렬</td>
<td>안정적 정렬</td>
</tr>
<tr>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(^2^)</td>
<td>O</td>
<td>X</td>
</tr>
</table>

- 분할 정복 방법이 적용된 알고리즘
	- 분할 : 피벗을 기준으로 주어진 배열을 두 부분배열로 분할, 두 부분배열의 크기는 일정하지 않음
	- 정복 : 두 부분 배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분 배열을 정렬함
	- 결합 : 필요 없음
