---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"

title: "[알고리즘] 탐색 - 1"

categories:
  - algorithm

tags:
  - 알고리즘
---

## 탐색 개요
- 여러 개의 원소로 구성된 데이터에서 원하는 값을 가진 원소를 찾는 것<br>
- 데이터의 형태 - 리스트, 트리, 그래프 등<br>
- 내부 탐색 vs 외부 탐색<br>
- 관련 연산 -> 탐색 + (초기화, 삽입, 삭제)<br><br>

- 탐색 방법<br>
	- 리스트 형태 : 순차 탐색, 이진 탐색<br>
	- 트리 형태 : 이진 탐색 트리, 2-3-4 트리, 레드-블랙 트리, B-트리<br>
	- 해시 테이블 : 해시 함수, 충돌 해결 방법<br><br>

## 순차탐색
- 리스트 형태로 주어진 원소들을 처음부터 하나씩 차례로 ("순차") 비교하면서 원하는 값을 가진 원소를 찾는 방법<br><br>

### 탐색 연산

``` c
SequentialSearch(A[], n, x){
	i=0;
	while(i<n && A[i]!=x) i = i+1;
	return(i)
}
```

### 삽입 연산

``` c
SequentialSearch_Insert(A[], n, x){
	A[n] = x; 
	return(A, n+1);
}
```

### 삭제 연산

``` c
SequentialSearch_Delete(A[], n, x){
	Index = SequentialSearch(A, n, x);
	if(Index == -1) return(A, n);
	A[Index] = A[n-1];
	return(A, n-1);
}
```

### 성능 및 특징<br>
- 탐색 성공 시<br>
	- 1번~n번 비교<br>
	- 평균 (n+1)/2회<br>
- 탐색 실패 시
	- 항상 n번 비교<br>
	- O(n)<br><br>

- 삭제<br>
	- 삭제할 원소의 순차 탐색 O(n) 후, 마지막 원소의 이동 <br>
	- O(1)<br><br>

- 삽입 연산의 시간 복잡도<br>
	- 리스트의 마지막에 추가하는데 상수 시간만 필요<br>
	- O(1)<br><br>

- 정렬되지 않고 크기가 작은 데이터에 적합<br>
- 모든 리스트 형태의 입력에 적용 가능<br>
	- 비정렬 데이터 탐색에 적합<br>
- 탐색과 삭제에 O(n) 시간이 필요<br>
	- 데이터가 큰 경우에는 부적합<br><br>
