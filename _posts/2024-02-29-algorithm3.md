---
레이아웃 : 단일
auther_profile: true
사이드바: 
  nav: "sidebar-category"
  
title: "[알고리즘] 정렬 -1"

범주:
 -알고리즘

태그:
 - 알고리즘
---

## 정렬

- 주어진 데이터를 값의 크기 순서에 따라 재배치하는 것<br><br>

### 내부정렬 vs 외부정렬
- 정렬 수행 시점에 데이터가 어디에 저장되어 있는가?<br><br>

1. 내부정렬<br>
- 전체 데이터를 주기억장치에 저장한 후 정렬을 수행하는 방식<br><br>
		
	1) **비교 기반 알고리즘<br>
		- 알고리즘의 성능 = 비교횟수**<br>
		- 선택정렬, 버블정렬, 삽입정렬, 셸정렬 (O(n^2^))<br>
		- 퀵정렬, 합병정렬, 힙정렬 (O(nlogn))<br><br>
		
	2) 데이터 분포 기반 알고리즘<br>
		- 알고리즘의 성능 = 데이터의 이동 횟수 (O(n))<br>
		- 계수정렬, 기수정렬, 버킷정렬<br>
 - 사전에 데이터 정보를 알아야 하기에 일반적으로는 비교기반을 사용<br><br>
	
2. 외부정렬<br>
- 모든 데이터를 주기억장치에 저장할 수 없는 경우, 보조기억장치에 저장해 두고 일부 데이터만을 반복적으로 주기억장치에 옮겨와 정렬을 수행<br><br>

### 기본 개념
- 안정적 정렬<br>
	- 동일한 값을 갖는 데이터가 여러 개 있을 때 정렬 전의 위치가 정렬 후에도 유지가 되는 정렬<br><br>- 제자리 정렬<br>
- 제자리 정렬<br>
	- 입력 배열 이외에 별도로 필요한 저장 공간이 상수 개를 넘지 않는 정렬<br>
	- 입력 크기 n이 증가함에도 불구하고 추가적인 저장 공간은 증가하지 않음<br><br>
- 기본 가정<br>
- 기본 가정<br>
	- 입력 데이터의 크기는 양의 정수이며, A[0~n-1]로 구성<br>
	- 입력 크기는 n<br>
	- 기본적인 정렬 방식은 오름차순<br><br><br>
## 선택 정렬
- 입력 배열에서 가장 작은 값부터 순서대로 '선택'해서 나열하는 방식<br><br>
- 입력 배열에서 가장 작은 값부터 순서대로 '선택'해서 나열하는 방식<br><br>
[![selection- sort.png](https://i.postimg.cc/pybQ07H8/selection-sort.png)](https://postimg.cc/bSg2rmdN)

<br>
<br>
```java
for(i=0; i<n-1; i++){ //(n-1)번 반복
	min = i;
	for(j=i+1; j<n; j++){ //A[i...ㅜ-1]에서 최솟값 찾기
		if(A[min]>A[j]) min = j;
	}
	A[i]와 A[min]의 자리 바꿈 로직; // 최소값과 A[i]의 위치 교환
}
```

<br>

- 특징<br>
	- 입력 데이터의 순서에 민감하지 않음. 미정렬 분에 대해 항상 (n-1)-i번의 비교가 필요<br>
	- 입력 데이터의 상태와 상관 없이 항상 동일한 성능 O(n^2^)을 가짐<br>
	- 제자리 정렬 알고리즘임. 입력배열 A[n]외에 i, j, min, tmp 4개의 저장 공간만 필요<br>
	- 안정적이지 않은 정렬 알고리즘임. 정렬 과정에 순서가 바뀔 수 있음<br>

<table>
<tr>
<td>성능</td>
<td>제자리 정렬</td>
<td>안정적 정렬</td>
</tr>
<tr>
<td>O(^2^)</td>
<td>O</td>
<td>X</td>
</tr>
</table>

<br><br><br>

## 버블 정렬
- 모든 인접한 두 데이터를 차례대로 비교해서 왼쪽 데이터가 더 큰 경우에는 오른쪽 데이터와 자리를 바꾸는 과정을 반복해서 정렬을 수행하는 방식<br><br>

[![992-CE7475-C6-C2-A940-D.png](https://i.postimg.cc/wxtggfCh/992-CE7475-C6-C2-A940-D.png)](https://postimg.cc/SjpwGrNs)

<br>

```java
for(i=0; i<n-1; i++){ //(n-1)번 반복
	for(j=0; j<n-1; j++){
		if(A[j]>)A[j+1]) A[j]와 A[j+1] 자리 바꿈 로직;
	}
}
```

<br>

- 특징<br>
 - 안정적인 알고리즘임. 인접한 두 데이터가 같은 경우 위치 교환이 발생하지 않음<br>
 - 제자리 정렬 알고리즘임.  입력배열 A[n]외에 i, j, tmp 3개의 저장 공간만 필요<br>
	- 선택 정렬에 비해 데이터 교환이 많이 발생. 선택 정렬보다 비효율적<br>

<table>
<tr>
<td>성능</td>
<td>제자리 정렬</td>
<td>안정적 정렬</td>
</tr>
<tr>
<td>O(^2^)</td>
<td>O</td>
<td>O</td>
</tr>
</table>

<br>

### 개선된 버블 정렬 알고리즘
- 각 루프의 반복 횟수를 줄여서 개선 가능<br>
	- 자리 바꿈이 발생하지 않으면 이미 정렬된 상태이므로 처리단계를 수행하지 않고 종료<br><br>

- 인접한 두 데이터의 비교 횟수<br>
	- 각 단계에서 두 데이터를 무조건 오른쪽/왼쪽 끝까지 이동하면서 인접한 두 데이터의 비교가 불필요<br>
	- 이미 제자리를 잡은 데이터에 대해서는 비교를 수행하지 않도록 함<br><br>

``` java
for(i=0; i<n-1; i++){
	sorted = true; //이미 정렬된 상태라고 가정 
	for(j=0; j<n-i-1; j++){ //이미 자리 잡은 범위는 배제
		if(A[j]>A[j+1]) {
			A[j]와 A[j+1] 자리 바꿈 로직;
			sorted = false; // 자리 바뀌면 미정렬 상태로 변경
		}
	}
	if(sorted == true) break; // 이미 정렬된 상태면 종료
}
```

<br>

- 정리<br>
	- 시간 복잡도는 동일하게 O(n^2^)<br>
	- 입력 데이터의 상태에 따라 성능이 달라짐. 이미 원하는 순서로 정렬된 경우 비교 횟수가 줄어듬<br>
	- 최선의 경우 : O(n)<br><br>

