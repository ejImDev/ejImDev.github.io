---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"

title: "[알고리즘] 정렬 -3"

categories:
  - algorithm

tags:
  - 알고리즘
---
## 정렬
### 힙정렬
- 자료구조 '힙'의 장점을 활용한 정렬<br>
- 임의의 값 삽입과 최댓값 삭제가 쉬움<br><br>

- 힙<br>
	- 완전 이진 트리<br>
	- 각 노드의 값은 자신의 자식 노드의 값보다 크거나 같아야 함 (최대힙)<br>
	- 1차원 배열을 이용해서 구현<br>
	- 2n+1, 2n+2 방식으로 자식노드를 찾을 수 있음<br><br>

- 처리과정<br>
	1. 1차원 배열을 힙으로 전환<br>
	2. i = (n-1) to 1<br>
	3. 힙의 최댓값 삭제<br>
	4. 힙의 재구성<br>
	5. 다시 2부터 데이터 수만큼 반복<br><br>

``` c
HeapSort(A[], n) {
	// 단계1. 새노드의 삽입. 힙으로 구성
	for(i=0; i<n; i++){
		par = (i/2)-1;
		while(par>=0 && A[par]<A[i]){
			A[par]과 A[i]의 교환;
			i = par;
			par = (i-1)/2;
		}
	}
	
	for(i=n-1; i>0; i--){
		최댓값 A[0]와 마지막노드 A[i]의 교환;
		cur=0; lch=1; rch=2;
		// 힙의 재구성
		do{
			if(rch<i && A[lch]<A[rch]) lch=rch;
			if(A[lch]>A[rch]){
				A[cur]과 A[lch]의 교환;
				cur = lch;
				lch = cur*2+1;
				rch = cur*2+2;
			} else lch = i;
		} while (lch<i)
	}
}
```

- 초기 힙 구축<br>
	- 1차원 배열을 힙으로 변환하는 것<br><br>
	- 방법<br>
		1. 주어진 입력 배열의 각 원소를 힙에 삽입하는 과정을 반복<br>
		2. 주어진 입력 배열을 우선 완전 이진트리로 만든 후, 각 노드에 대해 아래에서 위로 + 오른쪽에서 왼쪽으로 진행하면서 해당 노드의 아랫부분이 힙의 조건을 만족할 수 있도록 트리를 따라 내려가면서 자신의 자손 노드들과의 위치 교환을 계속해 나가는 방법<br><br>

- 방법1<br>
[![images-hammii-post-e4bffb9d-467f-4306-b4be-302204168c22-2021-09-06-5-22-08.png](https://i.postimg.cc/m2BpzGyv/images-hammii-post-e4bffb9d-467f-4306-b4be-302204168c22-2021-09-06-5-22-08.png)](https://postimg.cc/kDYvzzZs)

- 재구성(삭제)<br>
[![images-hammii-post-ecd3ee21-4429-48cb-a5a1-2659784d537d-2021-09-06-5-22-38.png](https://i.postimg.cc/pdCLvvkP/images-hammii-post-ecd3ee21-4429-48cb-a5a1-2659784d537d-2021-09-06-5-22-38.png)](https://postimg.cc/7CCk1ppR)




### 계수정렬


### 기수정렬


### 버킷정렬
