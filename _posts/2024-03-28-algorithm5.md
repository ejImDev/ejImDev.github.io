---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"

title: "[알고리즘] 정렬 -3"

categories:
  - algorithm

tags:
  - 알고리즘
---
## 정렬
### 힙정렬
- 자료구조 '힙'의 장점을 활용한 정렬<br>
- 임의의 값 삽입과 최댓값 삭제가 쉬움<br><br>

- 힙<br>
	- 완전 이진 트리<br>
	- 각 노드의 값은 자신의 자식 노드의 값보다 크거나 같아야 함 (최대힙)<br>
	- 1차원 배열을 이용해서 구현<br>
	- 2n+1, 2n+2 방식으로 자식노드를 찾을 수 있음<br><br>

- 처리과정<br>
	1. 1차원 배열을 힙으로 전환<br>
	2. i = (n-1) to 1<br>
	3. 힙의 최댓값 삭제<br>
	4. 힙의 재구성<br>
	5. 다시 2부터 데이터 수만큼 반복<br><br>

``` c
HeapSort(A[], n) {
	// 단계1. 새노드의 삽입. 힙으로 구성
	for(i=0; i<n; i++){
		par = (i/2)-1;
		while(par>=0 && A[par]<A[i]){
			A[par]과 A[i]의 교환;
			i = par;
			par = (i-1)/2;
		}
	}
	
	for(i=n-1; i>0; i--){
		최댓값 A[0]와 마지막노드 A[i]의 교환;
		cur=0; lch=1; rch=2;
		// 힙의 재구성
		do{
			if(rch<i && A[lch]<A[rch]) lch=rch;
			if(A[lch]>A[rch]){
				A[cur]과 A[lch]의 교환;
				cur = lch;
				lch = cur*2+1;
				rch = cur*2+2;
			} else lch = i;
		} while (lch<i)
	}
}
```

- 초기 힙 구축<br>
	- 1차원 배열을 힙으로 변환하는 것<br><br>
	- 방법<br>
		1. 주어진 입력 배열의 각 원소를 힙에 삽입하는 과정을 반복<br>
		2. 주어진 입력 배열을 우선 완전 이진트리로 만든 후, 각 노드에 대해 아래에서 위로 + 오른쪽에서 왼쪽으로 진행하면서 해당 노드의 아랫부분이 힙의 조건을 만족할 수 있도록 트리를 따라 내려가면서 자신의 자손 노드들과의 위치 교환을 계속해 나가는 방법<br><br>

- 방법1
[![images-hammii-post-e4bffb9d-467f-4306-b4be-302204168c22-2021-09-06-5-22-08.png](https://i.postimg.cc/m2BpzGyv/images-hammii-post-e4bffb9d-467f-4306-b4be-302204168c22-2021-09-06-5-22-08.png)](https://postimg.cc/kDYvzzZs)

- 방법2
[![images-hammii-post-ecd3ee21-4429-48cb-a5a1-2659784d537d-2021-09-06-5-22-38.png](https://i.postimg.cc/pdCLvvkP/images-hammii-post-ecd3ee21-4429-48cb-a5a1-2659784d537d-2021-09-06-5-22-38.png)](https://postimg.cc/7CCk1ppR)

- 재구성<br><br>

- 특징<br>
	- 최선, 최악, 평균 수행시간 : O(nlogn)<br>
	- 초기 힙 생성 최댓값 삭제 및 힙 재구성<br>
		- 바깥 루프 : 입력 크기 n에 비례<br>
		- 안쪽 루프 : 완전 이진 트리 높이 logn에 비례<br><br>

<table>
<tr>
<td>평균 성능</td>
<td>최선 성능</td>
<td>최악 성능</td>
</tr>
<tr>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
</tr>
</table>

## 정렬 알고리즘
### 비교기반의 정렬 알고리즘
- 기본성능 O(n^2^) : 선택정렬, 버블 정렬, 삽입 정렬, 셸 정렬<br>
- 향상된 평균 성능 O(nlogn) : 퀵 정렬, 합병 정렬, 힙 정렬<br>
- **비교 기반 정렬 알고리즘 성능의 하한 = O(nlogn)**<br>
- 아무리 빨라도 O(nlogn)보다 효율적인 알고리즘은 구할 수 없음<br><br>

### 이미 얻어진 데이터 분포 정보를 활용하는 정렬 알고리즘
- 계수정렬, 기수정렬, 버킷 정렬<br>
- 선형시간 O(n)이 가능<br><br>

### 계수정렬
- 주어진 데이터 중에서 자신보다 작거나 같은 값을 갖는 데이터의 개수를 계산하여 정렬할 위치를 찾아 정렬하는 방식<br>
- 입력값이 어떤 작은 정수 범위 내에 있다는 것을 알고 있는 경우에 적용 가능<br>
- k보다 작거나 같은 값을 갖는 데이터의 개수 => 정렬 순서상 k의 마지막 위치<br>
- 자신보다 작거나 같은 값을 갖는 데이터의 개수의 효율적인 계산 방법<br>
	- 입력값의 범위 a~b에 해당하는 크기의 배열 COUNT[a..b]를 할당하고, 주어진 값들을 한 번 쭉 훑으면 각 입력값의 출현횟수의 누적값 계산이 가능<br><br>

``` c
CountingSort(A[1..n], n) {
	MIN = MAX = A[1];
	// 입력값의 범위 MIN~MAX 계산
	for(i=2; i<=n; i++){
		if(A[i]<MIN) MIN=A[i];
		if(A[i]>MAX) MAX=A[i];
	}
	for(j=MIN; j<=MAX; j++) COUNT[j]=0;
	// 각 입력값의 출현횟수 계산
	for(i=1; i<=n; i++) COUNT[A[i]]++;
	//각 입력값의 출현횟수의 누적값 계산
	for(j=MIN+1; j<=MAX; j++) COUNT[j]=COUNT[j]+COUNT[j-1];
	//입력배열A[] -> 정렬배열B[] 
	for(i=n; i<0; i--) {
		B[COUNT[A[i]]=A[i];
		COUNT[A[i]]--;
	}
	return(B)
}
```

- 특징<br>
	- 입력값의 범위가 데이터의 개수보다 작거나 비례할 때 유용<br>
	- 입력값의 범위를 k라고 할 때 O(n+k) 시간<br>
	- k=O(n)이 되어야 선형 시간 O(n)에 동작<br>
	- 안정적인 정렬 알고리즘. 입력배열 A[]의 오른쪽의 것부터 뽑아서 배열 B[]의 오른쪽에서부터 저장<br>
	- 제자리 정렬 알고리즘이 아님. 입력배열에 따라 COUNT 추가 공간 필요<br>
	- 보편직이지 못한 정렬 알고리즘. 입력값의 범위를 미리 알아야함 + 추가적인 배열 필요 <br><br>

<table>
<tr>
<td>성능</td>
<td>안정적 알고리즘</td>
<td>제자리 정렬 알고리즘</td>
</tr>
<tr>
<td>O(n)</td>
<td>O</td>
<td>X</td>
</tr>
</table>

### 기수정렬


### 버킷정렬
