---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"
  
title: "[JAVA] 인터페이스와 추상클래스"

categories:
  - java
tags:
  - JAVA
---

## 추상 클래스
1. 추상 메소드<br>
- abstract 키워드를 사용<br>
- 몸체의 구현이 없이 형식만 존재하는 메소드<br>
- 자식 클래스에 상속될 때, 몸체의 구현이 필요<br>
- final과 함께 사용할 수 없음<br><br>

2. 추상 클래스<br>
- 클래스 정의에 abstract 키워드를 사용함<br>
- 데이터 필드나 일반 메소드를 포함할 수 있음<br>
- **객체 생성을 할 수 없음** (구체적이지 못한 불완전 클래스)<br>
- **추상 메소드를 포함하는 클래스는 반드시 추상 클래스**여야 함<br><br>

3. 추상 클래스의 사용<br>
- 의미적으로 유사한 클래스를 묶고자 할 때 사용. 공통으로 사용할 데이터 필드와 메소드 정의<br>
- 추상 클래스는 불완전한 클래스. 기능적으로 구현하기 어려운 메소드가 존재<br>
- 추상 클래스는 **자식 클래스로 상속되어 사용** 됨. 자식 클래스에서 추상 메소드를 구현<br>
- 추상 메소드를 구현한 자식 클래스는 객체 생성이 가능<br>
- **추상 클래스는 일반 클래스와 인터페이스의 중간적 성격을 가짐**<br><br>

## 인터페이스
- 100% 추상적 클래스<br>
- 인터페이스의 모든 메소드가 추상 메소드<br>
- 단, 몸체가 구현 된 default 메소드와 static 메소드도 포함 가능<br>
- 모든 메소드의 기본 접근 제어자는 public<br>
- 데이터 필드는 클래스 상수만 가능 (public static final)<br>
- 참조 자료형이며 직접적 객체 생성은 불가<br>
- 인터페이스의 이름은 보통 형용사<br><br>

1. 인터페이스의 정의<br>
- 문법은 클래스 정의와 유사<br>
- class 대신에 interface를 사용. abstract 는 생략하는 것이 일반적<br>
- 메소드는 기본적으로 public abstract <br>
- default 메소드와 static 메소드도 가능하나, 이 경우 몸체를 구현해야함<br>
- 데이터 필드는 항상 public static final<br><br>

2. 인터페이스의 사용<br>
- 자식 클래스에 상속되어 사용. 상속받는 자식클래스는 모든 추상메소드를 구현해주어야 함<br>
- 의미적으로는 관련이 없으나 기능적으로 유사한 클래스들을 묶을 때 인터페이스를 사용할 수 있음<br>
	- 예: 대소 비교가 가능한 객체들의 자료형을 묶을 때<br>
- 인터페이스를 상속받아 자식 인터페이스를 정의할 수 있음. 인터페이스의 상속 또는 확장<br>
- **자식 인터페이스가 부모 인터페이스를 상속받는 경우 extends 사용 (다중 상속 가능)**<br>
- **자식클래스가 부모 인터페이스를 상속받는 경우 implements를 사용**<br><br>

## 디폴트 메소드
- 인터페이스에서 선언하는 메소드에 기본 구현을 넣을 수 있음<br>
- 자식 클래스에서 상속받을 때, 디폴트 메소드를 그대로 사용하거나 몸체를 재정의할 수 있음<br>
- 메소드 선언시 default를 사용하고 몸체를 구현<br>
- 인터페이스에 나열된 기능을 확장할 때, 기존 코드의 수정을 피하기 위함<br>
- 단순히 추상 메소드가 추가된다면, 이전 인터페이스를 구현한 클래스를 수정해야 함<br>
``` java
interface DoIt {
	...
	default boolean method(int i, String s) {
		...
	}
}
```

## 추상클래스, 인터페이스, 클래스의 형변환
- 인터페이스와 클래스는 모두 사용자 정의형<br>
- extends와 implements에 따라 상위/하위 자료형 관계가 설정<br>
- 상위 유형의 변수는 하위 객체의 참조값을 가질 수 있음<br>
- 상위 유형의 변수가 가리키는 객체의 실제 유형에 따라 수행되는 메소드가 결정됨(동적 바인딩)<br>

## 다형성
- 유사하지만 다양한 형상이나 다양한 기능을 가진다는 뜻<br>
- 한 부모에서 나온 두 자식 객체는 비슷하지만 다름<br>
- 하나의 클래스에서 오버로딩 된 메소드들은 유사하지만 조금씩 다른 기능을 수행함<br>
- 자식 클래스에서 재정의된 메소드는 부모의 것과 유사하지만 다른 기능을 수행함<br><br>

1. 형 변환<br>
- 상속 관계에 있는 클래스 간에는 타입 변환이 가능함<br>
- 전혀 다른 두 클래스 간에는 타입 변환이 금지 됨<br>
- 하위 클래스에서 상위 클래스로 형 변환은 문제 없음<br>
	- 업캐스팅이라 하며 자동으로 형 변환 가능<br>
	- 참조형 변수는 같은 유형의 객체 또는 하위 객체를 참조할 수 있음<br>
	- ``Animal animal = (Animal) new Dog();``<br><br>

2. 클래스의 다형성<br>
	- 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 오버라이딩 할 수 있음<br>
	- 부모와 자식에서 같은 이름의 메소드가 다른 기능을 수행<br><br>
	
3. 인터페이스의 다형성<br>
	- 자식 클래스들에서 상위 인터페이스의 메소드를 다르게 구현함<br>

