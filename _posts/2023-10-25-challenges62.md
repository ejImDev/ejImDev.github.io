---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"
  
title: "[JAVA] 알고리즘 문제풀이 기초 - DFS, BFS -2"

categories:
  - javaTest
tags:
  - JAVA
  - Test
---
	
## 경로 탐색

- DFS 방향 그래프<br>

``` java
import java.util.*;

public class Main {

    static int n, m;
    static int answer = 0;
    static int[][] grape;
    static int[] ch;

    public void DFS(int v){
        ch[v]=1;
        if(v==n) {
            answer++;
        }
        else {
            for(int i=1; i<=n; i++){
                if(ch[i]!=1 && grape[v][i]==1) DFS(i);
            }
        }
        ch[v]=0;
    }

    public static void main(String[] args) {
        Main t = new Main();
        Scanner scan = new Scanner(System.in);
        n = scan.nextInt();
        m = scan.nextInt();
        grape = new int[n+1][n+1];
        ch = new int[n+1];
        for(int i=0; i<m; i++){
            int a = scan.nextInt();
            int b = scan.nextInt();
            grape[a][b] = 1;
        }

        ch[1]=1;
        t.DFS(1);
        System.out.println(answer);
    }
}
```

- 정리
	1. 일단 정점 n과 방향 이동 m개의 선이 있음을 받음<br>
	2. 각 정점의 이동경로가 있는지 입력받기 위해 n*n으로 이루어진 2차원배열을 만듬<br>
	3. m번의 반복을 돌아서 이동이 있는 데이터를 (a경로에서 b의 경로) 입력 받고, 확인되었다면 그래프배열 a,b의 값을 1로 바꿈<br>
	4. 재귀함수를 돌았는지 체크하기 위해 사이즈 n의 1차원배열도 만들어줌<br>
	5. 재귀함수에 찾고자하는 끝점의 데이터가 들어왔다면 answer을 증가<br>
	6. 끝점이 아니라면 반복을 돌면서 1부터 n까지의 방향을 돌되<br>
	7. 이미 방문한 정점은 배제(ch가 1이 아닐경우), 그래프에 존재하지 않는 이동경로라면 배제(그래프배열 a,b의 값이 1이 아닐경우)<br><br><br>

- 인접리스트<br>
```
import java.util.*;

public class Main {

    static int n, m;
    static int answer = 0;
    static ArrayList<ArrayList<Integer>> grape;
    static int[] ch;

    public void DFS(int v){
        if(v==n) {
            answer++;
        }
        else {
            for (Integer integer : grape.get(v)) {
                if(ch[integer]==0) {
                    ch[integer]=1;
                    DFS(integer);
                    ch[integer]=0;
                }
            }
        }
    }

    public static void main(String[] args) {
        Main t = new Main();
        Scanner scan = new Scanner(System.in);
        n = scan.nextInt();
        m = scan.nextInt();
        grape = new ArrayList<ArrayList<Integer>>();
        for(int i=0; i<=n; i++){
            grape.add(new ArrayList<Integer>());
        }
        ch = new int[n+1];
        for(int i=0; i<m; i++){
            int a = scan.nextInt();
            int b = scan.nextInt();
            grape.get(a).add(b);
        }

        ch[1]=1;
        t.DFS(1);
        System.out.println(answer);
    }
}
```

- 정리
	1. 행렬로 구현하는것은 정점의 수가 많아진다면 상당히 비효율적임<br>
	2. 리스트<리스트<Integer>()>() 형식으로 생성하고 이때 각 정점에 해당하는 그래프에 해당 정점이 이동하는 정점을 추가하는 방식으로 구현함<br>
	3. 일단 정점수를 입력받았다면 반복문을 통해 정점+1만큼의 각 리스트를 1차 리스트에 추가해줌 (0은 사용하지 않기에 +1 해야함)<br>
	4. 이동데이터를 확인하여 각 정점 리스트에 이동정점을 추가해줌
	5. DFS로 접근하는 방식은 행렬과 동일<br>
	6. 다만 행렬에서는 for문보다 foreach문을 사용하는 것이 효율적<br><br>
