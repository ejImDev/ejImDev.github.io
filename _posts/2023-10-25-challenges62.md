---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"
  
title: "[JAVA] 알고리즘 문제풀이 기초 - DFS, BFS -2"

categories:
  - javaTest
tags:
  - JAVA
  - Test
---
	
## 경로 탐색

- DFS 방향 그래프<br>

``` java
import java.util.*;

public class Main {

    static int n, m;
    static int answer = 0;
    static int[][] grape;
    static int[] ch;

    public void DFS(int v){
        ch[v]=1;
        if(v==n) {
            answer++;
        }
        else {
            for(int i=1; i<=n; i++){
                if(ch[i]!=1 && grape[v][i]==1) DFS(i);
            }
        }
        ch[v]=0;
    }

    public static void main(String[] args) {
        Main t = new Main();
        Scanner scan = new Scanner(System.in);
        n = scan.nextInt();
        m = scan.nextInt();
        grape = new int[n+1][n+1];
        ch = new int[n+1];
        for(int i=0; i<m; i++){
            int a = scan.nextInt();
            int b = scan.nextInt();
            grape[a][b] = 1;
        }

        ch[1]=1;
        t.DFS(1);
        System.out.println(answer);
    }
}
```

- 정리
	1. 일단 정점 n과 방향 이동 m개의 선이 있음을 받음
	2. 각 정점의 이동경로가 있는지 입력받기 위해 n*n으로 이루어진 2차원배열을 만듬
	3. m번의 반복을 돌아서 이동이 있는 데이터를 (a경로에서 b의 경로) 입력 받고, 확인되었다면 그래프배열 a,b의 값을 1로 바꿈
	4. 재귀함수를 돌았는지 체크하기 위해 사이즈 n의 1차원배열도 만들어줌
	5. 재귀함수에 찾고자하는 끝점의 데이터가 들어왔다면 answer을 증가
	6. 끝점이 아니라면 반복을 돌면서 1부터 n까지의 방향을 돌되
	7. 이미 방문한 정점은 배제(ch가 1이 아닐경우), 그래프에 존재하지 않는 이동경로라면 배제(그래프배열 a,b의 값이 1이 아닐경우)

