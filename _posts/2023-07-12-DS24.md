---
layout : single
author_profile: true
sidebar: 
  nav: "sidebar-category"

title: "[자료구조] 그래프 -4"

categories:
  - ds
tags:
  - DS
  - 자료구조
---

**본문과 관련하여 실습한 전체코드는 리파지토리에 별도 작성하였습니다.**<br>
: https://github.com/ejImDev/data_structure_study.git<br><br>

## 최소신장트리
- 신장트리(Spanning Tree) : 주어진 그래프가 **하나의 연결성분**으로 구성되어 있을 때, 그래프의 **모든 정점**들을 **싸이클 없이** 연결하는 부분 그래프<br>
- 최소신장트리(Minimum Spanning Tree, MST) : 하나의 연결성분으로 이루어진 무방향 가중치 그래프에서 간선의 가중치의 합이 최소인 신장 트리<br>
- MST를 찾는 대표적인 알고리즘은 Kruskal, Prim, Sollin 알고리즘<br>
	- 모두 그리디(Greedy) 알고리즘<br>
- 그리디 알고리즘 : 최적해(최솟값 또는 최댓값)를 찾는 문제를 해결하기 위한 알고리즘 방식들 중 하나로서, 알고리즘의 선택이 항상 '욕심내어' 지역적인 최솟값(또는 최댓값)을 선택하며, 이러한 부분적인 선택을 축적하여 최적해를 찾음<br><br>

## Kruskal 알고리즘
- 간선들을 가중치가 감소하지 않는 순서로 정렬한 후, 가장 가중치가 작은 간선을 트리에 추가하여 싸이클을 만들지 않으면 트리 간선으로 선택하고, 싸이클을 만들면 버리는 일을 반복하여 N-1개의 간선이 선택되었을 때 알고리즘을 종료<br>
	- N은 그래프 정점의 수<br><br>

- Kruskal 알고리즘이 그리디 알고리즘인 이유 : 남아있는 (정렬된) 간선들 중에서 항상 '욕심 내어' 가중치가 가장 작은 간선을 가져오기 때문<br><br>

- 순서<br>
	1. 가중치가 감소하지 않는 순서로 간선 리스트 L을 만든다<br>
	2. while(트리의 간선 수 < N-1)<br>
	3. L에서 가장 작은 가중치를 가진 간선 e를 가져오고, e에서 L을 제거<br>
	4. if(간선 e가 T에 추가하여 싸이클을 만들지 않으면)<br>
	5. 간선 e를 T에 추가 <br><br>

## Dijkstra 알고리즘
- 최단경로 찾기는 주어진 가중치그래프에서 출발점으로부터 도착점까지의 최단경로를 찾는 문제<br>
- Dijkstra 알고리즘 : 출발점으로부터 각 정점까지의 최단거리 및 경로를 계산<br><br>

- 순서<br>
	1. 배열 D를 ∞로 초기화시킨다. 단, D[s]=0이다.<br>
	2. for(k=0; k<N; k++)<br>
	3. 방문 안된 각 정점 i에 대해 D[i]가 최소인 정점 minVertex를 찾고, 방문한다<br>
	4. for(minVertex에 인접한 각 정점 w에 대해서)<br>
	5. if(w가 방문 안된 정점이면)<br>
	6. if(D[minVertex] + 간선(minVertex, w)의 가중치 < D[w])<br>
	7. D[w] = D[minVertex]+간선(minVertex, w)의 가중치 // 간선완화<br>
	8. previous[w] = minVertex<br><br>

> 참고 자료 : '경기대학교 소프트웨어중심대학사업단 - JAVA 자료구조' https://youtu.be/yZD3up52MRE
